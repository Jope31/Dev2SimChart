<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composer Data Charting Tool</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* A light gray background */
        }
        .container {
            max-width: 1200px;
        }
        /* Style for the loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 sm:p-6 md:p-8">

    <div class="container mx-auto bg-white p-6 rounded-2xl shadow-lg">

        <header class="mb-8 border-b pb-4">
            <h1 class="text-3xl font-bold text-gray-900">Composer Data Charting Tool</h1>
            <p class="text-md text-gray-600 mt-1">Visualize live and backtest performance for your symphonies.</p>
        </header>

        <!-- Input Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Credentials and Symphonies -->
            <div class="space-y-4">
                <div>
                    <label for="apiKey" class="block text-sm font-medium text-gray-700">API Key</label>
                    <input type="password" id="apiKey" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="Enter your API Key">
                </div>
                <div>
                    <label for="secretKey" class="block text-sm font-medium text-gray-700">Secret Key</label>
                    <input type="password" id="secretKey" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="Enter your Secret Key">
                </div>
                <div>
                    <label for="accountId" class="block text-sm font-medium text-gray-700">Account ID</label>
                    <input type="text" id="accountId" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="Enter your Account ID">
                </div>
                <div>
                    <label for="symphonies" class="block text-sm font-medium text-gray-700">Symphonies (ID,YYYY-MM-DD)</label>
                    <textarea id="symphonies" rows="5" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="One symphony per line, e.g.&#10;FTZP9wjzjvnIw21KQtIL,2025-08-01&#10;anotherSymphonyID,2025-07-15"></textarea>
                </div>
                <button id="fetchButton" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150 ease-in-out flex items-center justify-center">
                    <span id="buttonText">Fetch and Chart Data</span>
                    <div id="loader" class="loader hidden ml-3"></div>
                </button>
            </div>

            <!-- Status Log -->
            <div>
                <label class="block text-sm font-medium text-gray-700">Status Log</label>
                <div id="statusLog" class="mt-1 h-80 bg-gray-50 p-3 rounded-md border border-gray-300 overflow-y-auto text-xs font-mono">
                    Welcome! Please enter your credentials and symphonies to begin.
                </div>
            </div>
        </div>

        <!-- Chart Section -->
        <div class="mt-8">
            <h2 class="text-xl font-semibold mb-4">Performance Chart</h2>
            <div class="bg-white p-4 rounded-lg shadow">
                <canvas id="performanceChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const apiKeyInput = document.getElementById('apiKey');
        const secretKeyInput = document.getElementById('secretKey');
        const accountIdInput = document.getElementById('accountId');
        const symphoniesInput = document.getElementById('symphonies');
        const fetchButton = document.getElementById('fetchButton');
        const buttonText = document.getElementById('buttonText');
        const loader = document.getElementById('loader');
        const statusLog = document.getElementById('statusLog');
        const chartCanvas = document.getElementById('performanceChart');
        let performanceChart; // To hold the chart instance

        // --- API Base URLs ---
        // Using a CORS proxy to bypass browser security restrictions for local development.
        // You may need to visit the proxy URL and click a button to activate it for your session.
        const CORS_PROXY = "https://cors-anywhere.herokuapp.com/";
        const BACKTEST_API_BASE = CORS_PROXY + "https://backtest-api.composer.trade/api/v2";
        const LIVE_API_BASE = CORS_PROXY + "https://stagehand-api.composer.trade/api/v1";

        /**
         * Logs a message to the on-screen status log.
         * @param {string} message - The message to log.
         * @param {string} type - 'info', 'success', or 'error'.
         */
        function logStatus(message, type = 'info') {
            const colorMap = {
                info: 'text-gray-600',
                success: 'text-green-600',
                error: 'text-red-600',
                warning: 'text-yellow-600'
            };
            const logEntry = document.createElement('div');
            logEntry.className = colorMap[type];
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            statusLog.appendChild(logEntry);
            statusLog.scrollTop = statusLog.scrollHeight; // Auto-scroll to bottom
        }

        /**
         * Fetches historical backtest data for a single symphony.
         * @param {string} apiKey - The user's API key.
         * @param {string} secretKey - The user's secret key.
         * @param {string} symphonyId - The ID of the symphony.
         * @param {string} startDate - The start date for the backtest.
         * @returns {Promise<object|null>} The backtest data or null on error.
         */
        async function fetchBacktestData(apiKey, secretKey, symphonyId, startDate) {
            const url = `${BACKTEST_API_BASE}/public/symphonies/${symphonyId}/backtest`;
            logStatus(`Fetching Backtest data for ${symphonyId}...`);
            
            const headers = {
                "Authorization": `Bearer ${secretKey}`,
                "x-api-key-id": apiKey,
                "x-origin": "public-api",
                "Content-Type": "application/json"
            };
            
            const payload = {
                capital: 10000,
                start_date: startDate,
                end_date: new Date().toISOString().split('T')[0], // Today's date
                broker: "apex",
                slippage_percent: 0.0005,
                backtest_version: "v2",
                apply_reg_fee: true,
                apply_taf_fee: true
            };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}. Response: ${errorText}`);
                }
                const data = await response.json();
                logStatus(`-> Success: Fetched backtest data for ${symphonyId}.`, 'success');
                return data;
            } catch (e) {
                logStatus(`--> ERROR fetching backtest data for ${symphonyId}: ${e.message}`, 'error');
                logStatus(`--> This may be a CORS issue. Try visiting the proxy URL to activate it.`, 'warning');
                return null;
            }
        }
        
        /**
         * Fetches live portfolio history for a single symphony.
         * @param {string} apiKey - The user's API key.
         * @param {string} secretKey - The user's secret key.
         * @param {string} accountId - The user's account ID.
         * @param {string} symphonyId - The ID of the symphony.
         * @returns {Promise<object|null>} The live data or null on error.
         */
        async function fetchLiveData(apiKey, secretKey, accountId, symphonyId) {
            const url = `${LIVE_API_BASE}/portfolio/accounts/${accountId}/symphonies/${symphonyId}`;
            logStatus(`Fetching Live data for ${symphonyId}...`);

            const headers = {
                "Authorization": `Bearer ${secretKey}`,
                "x-api-key-id": apiKey,
                "x-origin": "public-api"
            };

            try {
                const response = await fetch(url, { headers: headers });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}. Response: ${errorText}`);
                }
                const data = await response.json();
                logStatus(`-> Success: Fetched live portfolio data for ${symphonyId}.`, 'success');
                return data;
            } catch (e) {
                logStatus(`--> ERROR fetching live data for ${symphonyId}: ${e.message}`, 'error');
                return null;
            }
        }

        /**
         * Merges live and backtest data, calculates percentage returns.
         * @param {object} liveData - The raw live data from the API.
         * @param {object} backtestData - The raw backtest data from the API.
         * @param {string} symphonyId - The ID of the symphony.
         * @param {string} startDateFilter - The start date to filter data from.
         * @returns {object} An object containing merged data points.
         */
        function processAndMergeData(liveData, backtestData, symphonyId, startDateFilter) {
            const mergedData = {};

            // Process Live Data
            if (liveData && liveData.epoch_ms && liveData.deposit_adjusted_series) {
                const livePoints = liveData.epoch_ms.map((ms, i) => ({
                    ms: ms,
                    value: liveData.deposit_adjusted_series[i]
                })).sort((a, b) => a.ms - b.ms);

                let liveBaseline = null;
                for (const point of livePoints) {
                    const dateStr = new Date(point.ms).toISOString().split('T')[0];
                    if (dateStr >= startDateFilter) {
                        if (liveBaseline === null) liveBaseline = point.value;
                        if (!mergedData[dateStr]) mergedData[dateStr] = {};
                        if (liveBaseline > 0) {
                            mergedData[dateStr].live_pct = (point.value / liveBaseline) - 1;
                        }
                    }
                }
            }

            // Process Backtest Data
            if (backtestData && backtestData.dvm_capital && backtestData.dvm_capital[symphonyId]) {
                const symphonyTimeseries = backtestData.dvm_capital[symphonyId];
                const backtestBaseline = 10000; // As per the python script
                
                for (const dayKey in symphonyTimeseries) {
                    const dateObj = new Date(1970, 0, 1);
                    dateObj.setDate(dateObj.getDate() + parseInt(dayKey) + 1); // Adjust for timezone offset from UTC
                    const dateStr = dateObj.toISOString().split('T')[0];

                    if (dateStr >= startDateFilter) {
                        if (!mergedData[dateStr]) mergedData[dateStr] = {};
                        mergedData[dateStr].backtest_pct = (symphonyTimeseries[dayKey] / backtestBaseline) - 1;
                    }
                }
            }
            
            return mergedData;
        }

        /**
         * Main function to orchestrate fetching, processing, and charting.
         */
        async function handleFetchAndChart() {
            // --- 1. Get and Validate Inputs ---
            const apiKey = apiKeyInput.value.trim();
            const secretKey = secretKeyInput.value.trim();
            const accountId = accountIdInput.value.trim();
            const symphoniesText = symphoniesInput.value.trim();

            if (!apiKey || !secretKey || !accountId || !symphoniesText) {
                logStatus("Please fill in all credentials and symphony fields.", 'error');
                return;
            }

            const symphonyInputs = symphoniesText.split('\n')
                .map(line => line.trim())
                .filter(line => line)
                .map(line => {
                    const parts = line.split(',');
                    if (parts.length !== 2 || !parts[0].trim() || !parts[1].trim()) {
                        return null;
                    }
                    return { id: parts[0].trim(), startDate: parts[1].trim() };
                })
                .filter(Boolean); // Remove any null entries

            if (symphonyInputs.length === 0) {
                logStatus("Invalid symphony format. Use: SymphonyID,YYYY-MM-DD", 'error');
                return;
            }

            // --- 2. Update UI to show loading state ---
            fetchButton.disabled = true;
            buttonText.textContent = 'Fetching...';
            loader.classList.remove('hidden');
            logStatus(`Starting process for ${symphonyInputs.length} symphonies...`, 'info');

            // --- 3. Fetch and Process Data for all Symphonies ---
            const allChartData = [];
            for (const symphony of symphonyInputs) {
                logStatus(`--- Processing Symphony: ${symphony.id} ---`, 'info');
                const liveData = await fetchLiveData(apiKey, secretKey, accountId, symphony.id);
                const backtestData = await fetchBacktestData(apiKey, secretKey, symphony.id, symphony.startDate);

                if (liveData || backtestData) {
                    const processedData = processAndMergeData(liveData, backtestData, symphony.id, symphony.startDate);
                    allChartData.push({
                        symphonyId: symphony.id,
                        data: processedData
                    });
                } else {
                    logStatus(`Could not fetch any data for ${symphony.id}. Skipping.`, 'warning');
                }
            }

            // --- 4. Prepare Data for Chart.js ---
            if (allChartData.length > 0) {
                const allDates = [...new Set(allChartData.flatMap(d => Object.keys(d.data)))].sort();
                const datasets = [];

                allChartData.forEach(({ symphonyId, data }) => {
                    // Live Data Series
                    datasets.push({
                        label: `${symphonyId} - Live`,
                        data: allDates.map(date => data[date] ? data[date].live_pct * 100 : null),
                        borderColor: 'blue',
                        backgroundColor: 'rgba(0, 0, 255, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        spanGaps: true
                    });

                    // Backtest Data Series
                    datasets.push({
                        label: `${symphonyId} - Backtest`,
                        data: allDates.map(date => data[date] ? data[date].backtest_pct * 100 : null),
                        borderColor: 'orange',
                        backgroundColor: 'rgba(255, 165, 0, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        spanGaps: true
                    });
                });

                // --- 5. Render the Chart ---
                if (performanceChart) {
                    performanceChart.destroy(); // Clear previous chart
                }
                performanceChart = new Chart(chartCanvas, {
                    type: 'line',
                    data: {
                        labels: allDates,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: 'Symphony Performance: Live vs. Backtest'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2) + '%';
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Return (%)'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                }
                            }
                        }
                    }
                });
                logStatus('Chart rendered successfully!', 'success');
            } else {
                logStatus('No data available to chart.', 'warning');
            }

            // --- 6. Reset UI ---
            fetchButton.disabled = false;
            buttonText.textContent = 'Fetch and Chart Data';
            loader.classList.add('hidden');
        }

        // --- Event Listener ---
        fetchButton.addEventListener('click', handleFetchAndChart);
    </script>

</body>
</html>
```

### Important Next Step

The first time you use this updated version, you will likely need to "activate" the proxy for your browser session.

1.  Open a new browser tab.
2.  Go to this URL: [https://cors-anywhere.herokuapp.com/](https://cors-anywhere.herokuapp.com/)
3.  Click the button on that page that says **"Request temporary access to the demo server"**.

After doing that, return to your `index.html` page and try running the tool again. It should now be able to fetch the backtest data successful