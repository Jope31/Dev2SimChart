<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composer Data Charting Tool</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- date-fns adapter for Chart.js time scale -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg-primary: #ffffff;
            --color-bg-secondary: #f3f4f6;
            --color-bg-tertiary: #ffffff;
            --color-text-primary: #1f2937;
            --color-text-secondary: #4b5563;
            --color-text-muted: #6b7280;
            --color-border: #e5e7eb;
            --color-input-bg: #ffffff;
            --color-input-text: #111827;
            --color-input-border: #d1d5db;
            --color-button-primary-bg: #4f46e5;
            --color-button-primary-text: #ffffff;
            --color-button-secondary-bg: #e5e7eb;
            --color-button-secondary-text: #1f2937;
            --color-focus-ring: #4f46e5;
            --color-loader-bg: #f3f3f3;
            --color-loader-fg: #3498db;
            --color-shadow: rgba(0, 0, 0, 0.1);
        }

        .dark {
            --color-bg-primary: #36393f;
            --color-bg-secondary: #2f3136;
            --color-bg-tertiary: #202225;
            --color-text-primary: #dcddde;
            --color-text-secondary: #b9bbbe;
            --color-text-muted: #72767d;
            --color-border: #202225;
            --color-input-bg: #40444b;
            --color-input-text: #dcddde;
            --color-input-border: #202225;
            --color-button-primary-bg: #5865f2;
            --color-button-primary-text: #ffffff;
            --color-button-secondary-bg: #40444b;
            --color-button-secondary-text: #dcddde;
            --color-focus-ring: #5865f2;
            --color-loader-bg: #40444b;
            --color-loader-fg: #5865f2;
            --color-shadow: rgba(0, 0, 0, 0.2);
        }

        /* General styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            max-width: 1200px;
            background-color: var(--color-bg-primary);
            box-shadow: 0 10px 15px -3px var(--color-shadow), 0 4px 6px -2px var(--color-shadow);
        }
        /* Style for the loading spinner */
        .loader {
            border: 4px solid var(--color-loader-bg);
            border-top: 4px solid var(--color-loader-fg);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Update components to use CSS variables */
        h1, h2 { color: var(--color-text-primary); }
        p, label { color: var(--color-text-secondary); }
        header { border-bottom-color: var(--color-border); }
        input, textarea {
            background-color: var(--color-input-bg);
            color: var(--color-input-text);
            border-color: var(--color-input-border);
        }
        input:focus, textarea:focus {
            --tw-ring-color: var(--color-focus-ring);
            border-color: var(--color-focus-ring);
        }
        #fetchButton {
            background-color: var(--color-button-primary-bg);
            color: var(--color-button-primary-text);
        }
        #fetchButton:hover { filter: brightness(1.1); }
        #downloadChartBtn {
            background-color: var(--color-button-secondary-bg);
            color: var(--color-button-secondary-text);
            border: 1px solid var(--color-border);
        }
        #downloadChartBtn:hover { filter: brightness(1.1); }
        #statusLog {
            background-color: var(--color-bg-secondary);
            border-color: var(--color-border);
            color: var(--color-text-muted);
        }
        .dark #statusLog .text-green-600 { color: #43b581; }
        .dark #statusLog .text-red-600 { color: #f04747; }
        .dark #statusLog .text-yellow-600 { color: #faa61a; }
        .dark #statusLog .text-gray-600 { color: var(--color-text-muted); }

        #theme-toggle svg { transition: color 0.3s; }
        #theme-toggle:focus { --tw-ring-color: var(--color-focus-ring); }
        .dark #theme-icon-light { color: var(--color-text-secondary); }
        .dark #theme-icon-dark { color: var(--color-text-secondary); }

        #performanceChartContainer {
            background-color: var(--color-bg-primary);
            box-shadow: 0 4px 6px -1px var(--color-shadow), 0 2px 4px -1px var(--color-shadow);
        }

    </style>
</head>
<body class="p-4 sm:p-6 md:p-8">

    <div class="container mx-auto p-6 rounded-2xl">

        <header class="mb-8 border-b pb-4 flex justify-between items-center">
            <div>
                <h1 class="text-3xl font-bold">Composer Data Charting Tool</h1>
                <p class="text-md mt-1">Visualize live and backtest performance for your symphonies.</p>
            </div>
            <div>
                <button id="theme-toggle" class="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2">
                    <svg id="theme-icon-light" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                    </svg>
                    <svg id="theme-icon-dark" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                    </svg>
                </button>
            </div>
        </header>

        <!-- Input Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Credentials and Symphonies -->
            <div class="space-y-4">
                <div>
                    <label for="apiKey" class="block text-sm font-medium">API Key</label>
                    <input type="password" id="apiKey" class="mt-1 block w-full rounded-md shadow-sm sm:text-sm" placeholder="Enter your API Key">
                </div>
                <div>
                    <label for="secretKey" class="block text-sm font-medium">Secret Key</label>
                    <input type="password" id="secretKey" class="mt-1 block w-full rounded-md shadow-sm sm:text-sm" placeholder="Enter your Secret Key">
                </div>
                <div>
                    <label for="accountId" class="block text-sm font-medium">Account ID</label>
                    <input type="text" id="accountId" class="mt-1 block w-full rounded-md shadow-sm sm:text-sm" placeholder="Enter your Account ID">
                </div>
                <div>
                    <label for="symphonies" class="block text-sm font-medium">Symphonies (Name,ID,YYYY-MM-DD)</label>
                    <textarea id="symphonies" rows="5" class="mt-1 block w-full rounded-md shadow-sm sm:text-sm" placeholder="One symphony per line, e.g.&#10;My Awesome Symphony,FTZP9wjzjvnIw21KQtIL,2025-08-01&#10;Another Symphony,anotherSymphonyID,2025-07-15"></textarea>
                </div>
                <button id="fetchButton" class="w-full text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-150 ease-in-out flex items-center justify-center">
                    <span id="buttonText">Fetch and Chart Data</span>
                    <div id="loader" class="loader hidden ml-3"></div>
                </button>
            </div>

            <!-- Status Log -->
            <div>
                <label class="block text-sm font-medium">Status Log</label>
                <div id="statusLog" class="mt-1 h-80 p-3 rounded-md border overflow-y-auto text-xs font-mono">
                    Welcome! Please enter your credentials and symphonies to begin.
                </div>
            </div>
        </div>

        <!-- Chart Section -->
        <div class="mt-8">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold">Performance Chart</h2>
                <button id="downloadChartBtn" class="font-semibold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-150 ease-in-out text-sm">
                    Download PNG
                </button>
            </div>
            <div id="performanceChartContainer" class="p-4 rounded-lg">
                <canvas id="performanceChart"></canvas>
            </div>
        </div>

        <!-- Z-Score Ranking Section -->
        <div class="mt-8">
            <h2 class="text-xl font-semibold mb-4">Z-Score Ranking</h2>
            <div id="zScoreRanking" class="p-4 rounded-lg bg-gray-50 dark:bg-gray-800">
                <!-- Z-score results will be injected here -->
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const apiKeyInput = document.getElementById('apiKey');
        const secretKeyInput = document.getElementById('secretKey');
        const accountIdInput = document.getElementById('accountId');
        const symphoniesInput = document.getElementById('symphonies');
        const fetchButton = document.getElementById('fetchButton');
        const buttonText = document.getElementById('buttonText');
        const loader = document.getElementById('loader');
        const statusLog = document.getElementById('statusLog');
        const chartCanvas = document.getElementById('performanceChart');
        const downloadChartBtn = document.getElementById('downloadChartBtn');
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        let performanceChart; // To hold the chart instance

        // --- Theme Management ---
        const DARK_THEME = 'dark';
        const LIGHT_THEME = 'light';

        /**
         * Applies the selected theme.
         * @param {string} theme - The theme to apply ('dark' or 'light').
         */
        function applyTheme(theme) {
            if (theme === DARK_THEME) {
                document.documentElement.classList.add(DARK_THEME);
                themeIconLight.classList.add('hidden');
                themeIconDark.classList.remove('hidden');
            } else {
                document.documentElement.classList.remove(DARK_THEME);
                themeIconLight.classList.remove('hidden');
                themeIconDark.classList.add('hidden');
            }
            // If a chart exists, update its colors
            if (performanceChart) {
                updateChartTheme();
            }
        }

        /**
         * Toggles the current theme and saves the preference.
         */
        function toggleTheme() {
            const currentTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? DARK_THEME : LIGHT_THEME);
            const newTheme = currentTheme === DARK_THEME ? LIGHT_THEME : DARK_THEME;
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        }

        /**
         * Returns Chart.js options object based on the current theme.
         */
        function getChartOptions() {
            const styles = getComputedStyle(document.documentElement);
            const textColor = styles.getPropertyValue('--color-text-primary').trim();
            const mutedTextColor = styles.getPropertyValue('--color-text-muted').trim();
            const gridColor = styles.getPropertyValue('--color-border').trim();
            const chartBackgroundColor = styles.getPropertyValue('--color-bg-primary').trim();

            return {
                responsive: true,
                plugins: {
                    customCanvasBackgroundColor: {
                        color: chartBackgroundColor
                    },
                    legend: {
                        position: 'top',
                        labels: {
                            color: textColor,
                        }
                    },
                    title: {
                        display: true,
                        text: 'Symphony Performance: Live vs. Backtest',
                        color: textColor
                    },
                    tooltip: {
                        backgroundColor: styles.getPropertyValue('--color-bg-tertiary').trim(),
                        titleColor: textColor,
                        bodyColor: textColor,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += context.parsed.y.toFixed(2) + '%';
                                }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'day',
                            tooltipFormat: 'MMM d, yyyy'
                        },
                        title: {
                            display: true,
                            text: 'Date',
                            color: mutedTextColor
                        },
                        grid: {
                            color: gridColor,
                        },
                        ticks: {
                            color: mutedTextColor,
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Return (%)',
                            color: mutedTextColor
                        },
                        grid: {
                            color: gridColor,
                        },
                        ticks: {
                            color: mutedTextColor,
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                }
            };
        }

        /**
         * Updates the chart's theme.
         */
        function updateChartTheme() {
            if (!performanceChart) return;
            performanceChart.options = getChartOptions();
            performanceChart.update();
        }

        // --- Initial Theme Setup ---
        // On page load, apply the saved theme or the user's OS preference
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            applyTheme(savedTheme);
        } else {
            // If no theme is saved, check the OS preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                applyTheme(DARK_THEME);
            } else {
                applyTheme(LIGHT_THEME);
            }
        }

        // --- Color Palette ---
        // Pairs of dark/light colors for the charts.
        const colorPairs = [
            { dark: '#d62728', light: '#ff9896' }, // Red
            { dark: '#1f77b4', light: '#aec7e8' }, // Blue
            { dark: '#2ca02c', light: '#98df8a' }, // Green
            { dark: '#9467bd', light: '#c5b0d5' }, // Purple
            { dark: '#ff7f0e', light: '#ffbb78' }, // Orange
            { dark: '#8c564b', light: '#c49c94' }, // Brown
            { dark: '#e377c2', light: '#f7b6d2' }, // Pink
            { dark: '#7f7f7f', light: '#c7c7c7' }, // Gray
            { dark: '#bcbd22', light: '#dbdb8d' }, // Olive
            { dark: '#17becf', light: '#9edae5' }, // Cyan
            { dark: '#8B0000', light: '#E06666' }, // Dark Red
            { dark: '#000080', light: '#6666E0' }, // Navy
            { dark: '#32CD32', light: '#98FB98' }, // Lime
            { dark: '#800000', light: '#E08080' }, // Maroon
            { dark: '#FFD700', light: '#FFFACD' }, // Gold
            { dark: '#4B0082', light: '#B380E8' }, // Indigo
            { dark: '#FF7F50', light: '#FFA07A' }, // Coral
            { dark: '#40E0D0', light: '#AFEEEE' }, // Turquoise
            { dark: '#EE82EE', light: '#F5C2F5' }, // Violet
            { dark: '#F0E68C', light: '#FFFACD' }  // Khaki
        ];

        /**
         * Converts a HEX color to an RGBA string.
         * @param {string} hex - The hex color code (e.g., '#RRGGBB').
         * @param {number} alpha - The alpha transparency (0-1).
         * @returns {string} The RGBA color string.
         */
        function hexToRgba(hex, alpha = 1) {
            if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                return 'rgba(0,0,0,0)'; // Invalid hex
            }
            let c = hex.substring(1).split('');
            if (c.length === 3) {
                c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c = '0x' + c.join('');
            return `rgba(${[(c>>16)&255, (c>>8)&255, c&255].join(',')},${alpha})`;
        }

        /**
         * Calculates the mean and standard deviation of an array of numbers.
         * @param {number[]} data - Array of numbers.
         * @returns {{mean: number, stdDev: number}}
         */
        function calculateStatistics(data) {
            if (data.length === 0) return { mean: 0, stdDev: 0 };
            const sum = data.reduce((acc, val) => acc + val, 0);
            const mean = sum / data.length;
            const variance = data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / data.length;
            const stdDev = Math.sqrt(variance);
            return { mean, stdDev };
        }

        /**
         * Calculates rolling returns for a given duration.
         * @param {object} timeseries - Object with date strings as keys and equity values.
         * @param {number} durationDays - The number of days for the rolling period.
         * @returns {number[]} - An array of rolling returns.
         */
        function calculateRollingReturns(timeseries, durationDays) {
            const sortedPoints = Object.keys(timeseries)
                .map(date => ({ date: new Date(date), value: timeseries[date] }))
                .sort((a, b) => a.date - b.date);

            if (sortedPoints.length < 2 || durationDays <= 0) return [];

            const returns = [];
            const durationMs = durationDays * 24 * 60 * 60 * 1000;

            for (let i = 0; i < sortedPoints.length; i++) {
                const endDate = sortedPoints[i].date;
                const endValue = sortedPoints[i].value;
                const targetStartDate = new Date(endDate.getTime() - durationMs);

                // Find the closest start point on or before the target start date
                let startPoint = null;
                for (let j = i; j >= 0; j--) {
                    if (sortedPoints[j].date <= targetStartDate) {
                        startPoint = sortedPoints[j];
                        break;
                    }
                }

                if (startPoint) {
                    const startValue = startPoint.value;
                    if (startValue !== 0) {
                        const periodReturn = (endValue / startValue) - 1;
                        returns.push(periodReturn);
                    }
                }
            }
            return returns;
        }

        // --- API Base URLs ---
        // Using a CORS proxy to bypass browser security restrictions for local development.
        // You may need to visit the proxy URL and click a button to activate it for your session.
        const CORS_PROXY = "http://localhost:8080/";
        const BACKTEST_API_BASE = CORS_PROXY + "https://backtest-api.composer.trade/api/v2";
        const LIVE_API_BASE = CORS_PROXY + "https://stagehand-api.composer.trade/api/v1";

        /**
         * Logs a message to the on-screen status log.
         * @param {string} message - The message to log.
         * @param {string} type - 'info', 'success', or 'error'.
         */
        function logStatus(message, type = 'info') {
            const colorMap = {
                info: 'text-gray-600',
                success: 'text-green-600',
                error: 'text-red-600',
                warning: 'text-yellow-600'
            };
            const logEntry = document.createElement('div');
            logEntry.className = colorMap[type];
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            statusLog.appendChild(logEntry);
            statusLog.scrollTop = statusLog.scrollHeight; // Auto-scroll to bottom
        }

        /**
         * Fetches historical backtest data for a single symphony.
         * @param {string} apiKey - The user's API key.
         * @param {string} secretKey - The user's secret key.
         * @param {string} symphonyId - The ID of the symphony.
         * @param {string} startDate - The start date for the backtest.
         * @returns {Promise<object|null>} The backtest data or null on error.
         */
        async function fetchBacktestData(apiKey, secretKey, symphonyId, startDate) {
            const url = `${BACKTEST_API_BASE}/public/symphonies/${symphonyId}/backtest`;
            logStatus(`Fetching Backtest data for ${symphonyId}...`);

            const headers = {
                "Authorization": `Bearer ${secretKey}`,
                "x-api-key-id": apiKey,
                "x-origin": "public-api",
                "Content-Type": "application/json"
            };

            const payload = {
                capital: 10000,
                start_date: startDate,
                end_date: new Date().toISOString().split('T')[0], // Today's date
                broker: "apex",
                slippage_percent: 0.0005,
                backtest_version: "v2",
                apply_reg_fee: true,
                apply_taf_fee: true
            };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}. Response: ${errorText}`);
                }
                const data = await response.json();
                logStatus(`-> Success: Fetched backtest data for ${symphonyId}.`, 'success');
                return data;
            } catch (e) {
                logStatus(`--> ERROR fetching backtest data for ${symphonyId}: ${e.message}`, 'error');
                logStatus(`--> This may be a CORS issue. Try visiting the proxy URL to activate it.`, 'warning');
                return null;
            }
        }

        /**
         * Fetches live portfolio history for a single symphony.
         * @param {string} apiKey - The user's API key.
         * @param {string} secretKey - The user's secret key.
         * @param {string} accountId - The user's account ID.
         * @param {string} symphonyId - The ID of the symphony.
         * @returns {Promise<object|null>} The live data or null on error.
         */
        async function fetchLiveData(apiKey, secretKey, accountId, symphonyId) {
            const url = `${LIVE_API_BASE}/portfolio/accounts/${accountId}/symphonies/${symphonyId}`;
            logStatus(`Fetching Live data for ${symphonyId}...`);

            const headers = {
                "Authorization": `Bearer ${secretKey}`,
                "x-api-key-id": apiKey,
                "x-origin": "public-api"
            };

            try {
                const response = await fetch(url, { headers: headers });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}. Response: ${errorText}`);
                }
                const data = await response.json();
                logStatus(`-> Success: Fetched live portfolio data for ${symphonyId}.`, 'success');
                return data;
            } catch (e) {
                logStatus(`--> ERROR fetching live data for ${symphonyId}: ${e.message}`, 'error');
                return null;
            }
        }

        /**
         * Merges live and backtest data, calculates percentage returns.
         * @param {object} liveData - The raw live data from the API.
         * @param {object} backtestData - The raw backtest data from the API.
         * @param {string} symphonyId - The ID of the symphony.
         * @param {string} startDateFilter - The start date to filter data from.
         * @returns {object} An object containing merged data points.
         */
        function processAndMergeData(liveData, backtestData, symphonyId, startDateFilter) {
            const mergedData = {};

            // Process Live Data
            if (liveData && liveData.epoch_ms && liveData.deposit_adjusted_series) {
                const livePoints = liveData.epoch_ms.map((ms, i) => ({
                    ms: ms,
                    value: liveData.deposit_adjusted_series[i]
                })).sort((a, b) => a.ms - b.ms);

                let liveBaseline = null;
                for (const point of livePoints) {
                    const dateStr = new Date(point.ms).toISOString().split('T')[0];
                    if (dateStr >= startDateFilter) {
                        if (liveBaseline === null) liveBaseline = point.value;
                        if (!mergedData[dateStr]) mergedData[dateStr] = {};
                        if (liveBaseline > 0) {
                            mergedData[dateStr].live_pct = (point.value / liveBaseline) - 1;
                        }
                    }
                }
            }

            // Process Backtest Data
            if (backtestData && backtestData.dvm_capital && backtestData.dvm_capital[symphonyId]) {
                const symphonyTimeseries = backtestData.dvm_capital[symphonyId];
                const backtestBaseline = 10000; // As per the python script

                for (const dayKey in symphonyTimeseries) {
                    const dateObj = new Date(1970, 0, 1);
                    dateObj.setDate(dateObj.getDate() + parseInt(dayKey) + 1); // Adjust for timezone offset from UTC
                    const dateStr = dateObj.toISOString().split('T')[0];

                    if (dateStr >= startDateFilter) {
                        if (!mergedData[dateStr]) mergedData[dateStr] = {};
                        mergedData[dateStr].backtest_pct = (symphonyTimeseries[dayKey] / backtestBaseline) - 1;
                    }
                }
            }

            return mergedData;
        }

        /**
         * Main function to orchestrate fetching, processing, and charting.
         */
        async function handleFetchAndChart() {
            // --- 1. Get and Validate Inputs ---
            const apiKey = apiKeyInput.value.trim();
            const secretKey = secretKeyInput.value.trim();
            const accountId = accountIdInput.value.trim();
            const symphoniesText = symphoniesInput.value.trim();

            if (!apiKey || !secretKey || !accountId || !symphoniesText) {
                logStatus("Please fill in all credentials and symphony fields.", 'error');
                return;
            }

            const symphonyInputs = symphoniesText.split('\n')
                .map(line => line.trim())
                .filter(line => line)
                .map(line => {
                    const parts = line.split(',');
                    if (parts.length !== 3 || !parts[0].trim() || !parts[1].trim() || !parts[2].trim()) {
                        return null;
                    }
                    return { name: parts[0].trim(), id: parts[1].trim(), startDate: parts[2].trim() };
                })
                .filter(Boolean); // Remove any null entries

            if (symphonyInputs.length === 0) {
                logStatus("Invalid symphony format. Use: Name,SymphonyID,YYYY-MM-DD", 'error');
                return;
            }

            // --- 2. Update UI to show loading state ---
            fetchButton.disabled = true;
            buttonText.textContent = 'Fetching...';
            loader.classList.remove('hidden');
            logStatus(`Starting process for ${symphonyInputs.length} symphonies...`, 'info');

            // --- 3. Fetch and Process Data for all Symphonies ---
            const allChartData = [];
            const zScoreData = [];

            for (const symphony of symphonyInputs) {
                logStatus(`--- Processing Symphony: ${symphony.name} (${symphony.id}) ---`, 'info');
                const liveData = await fetchLiveData(apiKey, secretKey, accountId, symphony.id);
                const backtestData = await fetchBacktestData(apiKey, secretKey, symphony.id, symphony.startDate);

                if (liveData || backtestData) {
                    // Process for chart
                    const processedData = processAndMergeData(liveData, backtestData, symphony.id, symphony.startDate);
                    allChartData.push({
                        symphonyId: symphony.id,
                        name: symphony.name,
                        data: processedData
                    });

                    // Z-Score Calculation
                    logStatus(`Calculating Z-Score for ${symphony.name}...`);
                    let zScore = null;

                    if (liveData && liveData.epoch_ms && liveData.epoch_ms.length > 1) {
                        const livePoints = liveData.epoch_ms.map((ms, i) => ({
                            ms: ms,
                            value: liveData.deposit_adjusted_series[i]
                        })).sort((a, b) => a.ms - b.ms);

                        const firstPoint = livePoints[0];
                        const lastPoint = livePoints[livePoints.length - 1];
                        const liveDurationDays = Math.round((lastPoint.ms - firstPoint.ms) / (1000 * 60 * 60 * 24));

                        if (liveDurationDays > 0 && firstPoint.value > 0) {
                            const x = (lastPoint.value / firstPoint.value) - 1; // Total live return
                            logStatus(`Live duration for ${symphony.name}: ${liveDurationDays} days, Total Return: ${(x*100).toFixed(2)}%`);

                            if (backtestData && backtestData.dvm_capital && backtestData.dvm_capital[symphony.id]) {
                                const backtestTimeseries = backtestData.dvm_capital[symphony.id];
                                const backtestEquityCurve = {};
                                for (const dayKey in backtestTimeseries) {
                                    const dateObj = new Date(1970, 0, 1);
                                    dateObj.setDate(dateObj.getDate() + parseInt(dayKey) + 1);
                                    const dateStr = dateObj.toISOString().split('T')[0];
                                    backtestEquityCurve[dateStr] = backtestTimeseries[dayKey];
                                }

                                const historicalReturns = calculateRollingReturns(backtestEquityCurve, liveDurationDays);
                                if (historicalReturns.length > 0) {
                                    const { mean: mu, stdDev: sigma } = calculateStatistics(historicalReturns);
                                    if (sigma > 0) {
                                        zScore = (x - mu) / sigma;
                                        logStatus(`-> Z-Score for ${symphony.name}: ${zScore.toFixed(2)} (μ: ${(mu*100).toFixed(2)}%, σ: ${(sigma*100).toFixed(2)}%)`, 'success');
                                    } else {
                                        logStatus(`Std Dev of historical returns is zero for ${symphony.name}. Cannot calculate Z-Score.`, 'warning');
                                    }
                                } else {
                                    logStatus(`Could not calculate any historical rolling returns for a duration of ${liveDurationDays} days.`, 'warning');
                                }
                            } else {
                                logStatus(`No backtest data available for ${symphony.name} to calculate Z-Score.`, 'warning');
                            }
                        } else {
                            logStatus(`Live duration is zero or initial value is zero for ${symphony.name}. Cannot calculate Z-Score.`, 'warning');
                        }
                    } else {
                        logStatus(`Not enough live data to calculate duration and return for ${symphony.name}.`, 'warning');

                    }

                    if (zScore !== null) {
                        zScoreData.push({ name: symphony.name, zScore: zScore });
                    }

                } else {
                    logStatus(`Could not fetch any data for ${symphony.id}. Skipping.`, 'warning');
                }
            }

            // --- 4. Display Z-Score Rankings ---
            const zScoreRankingDiv = document.getElementById('zScoreRanking');
            zScoreRankingDiv.innerHTML = ''; // Clear previous results
            if (zScoreData.length > 0) {
                // Sort by absolute Z-score, least deviant to most deviant
                zScoreData.sort((a, b) => Math.abs(a.zScore) - Math.abs(b.zScore));

                const list = document.createElement('ul');
                list.className = 'space-y-2';
                zScoreData.forEach(item => {
                    const listItem = document.createElement('li');
                    listItem.className = 'flex justify-between items-center p-2 rounded-md bg-gray-100 dark:bg-gray-700';
                    const sign = item.zScore >= 0 ? '+' : '';
                    const zScoreColor = item.zScore >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400';
                    listItem.innerHTML = `
                        <span class="font-medium">${item.name}</span>
                        <span class="font-mono text-sm font-semibold ${zScoreColor}">${sign}${item.zScore.toFixed(2)}</span>
                    `;
                    list.appendChild(listItem);
                });
                zScoreRankingDiv.appendChild(list);
            } else {
                zScoreRankingDiv.innerHTML = '<p class="text-sm text-gray-500">No Z-Score data could be calculated. Check logs for details.</p>';
            }


            // --- 5. Prepare Data for Chart.js ---
            if (allChartData.length > 0) {
                const datasets = [];

                allChartData.forEach(({ name, data }, index) => {
                    const color = colorPairs[index % colorPairs.length];
                    const liveDataPoints = [];
                    const backtestDataPoints = [];

                    // Sort dates to ensure data points are in chronological order
                    const sortedDates = Object.keys(data).sort();

                    for (const date of sortedDates) {
                        const point = data[date];
                        if (point.live_pct !== undefined && point.live_pct !== null) {
                            liveDataPoints.push({ x: date, y: point.live_pct * 100 });
                        }
                        if (point.backtest_pct !== undefined && point.backtest_pct !== null) {
                            backtestDataPoints.push({ x: date, y: point.backtest_pct * 100 });
                        }
                    }

                    // Live Data Series
                    datasets.push({
                        label: `${name} - Live`,
                        data: liveDataPoints,
                        borderColor: color.dark,
                        backgroundColor: hexToRgba(color.dark, 0.1),
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        spanGaps: true
                    });

                    // Backtest Data Series
                    datasets.push({
                        label: `${name} - Backtest`,
                        data: backtestDataPoints,
                        borderColor: color.light,
                        backgroundColor: hexToRgba(color.light, 0.1),
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        spanGaps: true
                    });
                });

                // --- 5. Render the Chart ---
                if (performanceChart) {
                    performanceChart.destroy(); // Clear previous chart
                }

                performanceChart = new Chart(chartCanvas, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: getChartOptions(),
                    plugins: [{
                        id: 'customCanvasBackgroundColor',
                        beforeDraw: (chart, args, options) => {
                            const {ctx} = chart;
                            ctx.save();
                            ctx.globalCompositeOperation = 'destination-over';
                            ctx.fillStyle = chart.options.plugins.customCanvasBackgroundColor.color || '#ffffff';
                            ctx.fillRect(0, 0, chart.width, chart.height);
                            ctx.restore();
                        }
                    }]
                });
                logStatus('Chart rendered successfully!', 'success');
            } else {
                logStatus('No data available to chart.', 'warning');
            }

            // --- 6. Reset UI ---
            fetchButton.disabled = false;
            buttonText.textContent = 'Fetch and Chart Data';
            loader.classList.add('hidden');
        }


        /**
         * Handles downloading the chart as a PNG image.
         */
        function handleDownloadChart() {
            if (!performanceChart) {
                logStatus("No chart available to download. Please fetch data first.", 'warning');
                return;
            }

            // Chart.js's toBase64Image() method creates a base64-encoded string
            const imageLink = performanceChart.toBase64Image();

            // Create a temporary link element to trigger the download
            const link = document.createElement('a');
            link.href = imageLink;
            link.download = `composer-performance-chart-${new Date().toISOString().split('T')[0]}.png`; // e.g., composer-performance-chart-2025-08-09.png

            // Append to body, click, and then remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            logStatus("Chart download initiated.", 'info');
        }

        // --- Event Listeners ---
        fetchButton.addEventListener('click', handleFetchAndChart);
        downloadChartBtn.addEventListener('click', handleDownloadChart);
        themeToggle.addEventListener('click', toggleTheme);

    </script>

</body>
</html>
