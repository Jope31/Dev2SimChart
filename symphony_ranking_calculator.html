<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symphony Ranking Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for range sliders for better cross-browser appearance */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #e5e7eb; /* bg-gray-200 */
            border-radius: 9999px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6; /* bg-blue-600 */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6; /* bg-blue-600 */
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 md:p-8">
        <div class="bg-white rounded-2xl shadow-lg p-6 md:p-8">

            <h1 class="text-2xl md:text-3xl font-bold text-gray-900 mb-2">Symphony Ranking Calculator</h1>
            <p class="text-gray-600 mb-6">Calculate a weighted score for your symphonies based on multiple performance metrics.</p>

            <!-- Step 1: API Configuration -->
            <div class="mb-8">
                <h2 class="text-lg font-semibold text-gray-700 mb-2">Step 1: Configure API and Symphonies</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 mt-4">
                    <div>
                        <label for="apiKey" class="block text-sm font-medium text-gray-700">API Key</label>
                        <input type="password" id="apiKey" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label for="secretKey" class="block text-sm font-medium text-gray-700">Secret Key</label>
                        <input type="password" id="secretKey" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label for="startDate" class="block text-sm font-medium text-gray-700">Start Date</label>
                        <input type="date" id="startDate" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label for="endDate" class="block text-sm font-medium text-gray-700">End Date</label>
                        <input type="date" id="endDate" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div class="md:col-span-2">
                        <label for="symphonyIds" class="block text-sm font-medium text-gray-700">Symphony IDs</label>
                        <p class="text-sm text-gray-500 mb-2">Enter one Symphony ID per line.</p>
                        <textarea id="symphonyIds" rows="5" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-shadow duration-200 text-sm font-mono"></textarea>
                    </div>
                </div>
            </div>

            <!-- Step 2: Metric Weights -->
            <div class="mb-8">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Step 2: Adjust Metric Weights</h2>
                <div id="weightsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                    <!-- Sliders will be dynamically inserted here -->
                </div>
                <div class="mt-4 text-right font-semibold text-gray-700">
                    Total Weight: <span id="totalWeight" class="text-blue-600">100%</span>
                </div>
            </div>

            <!-- Step 3: Calculate -->
            <div class="text-center">
                <button id="calculateBtn" class="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:shadow-lg transform hover:-translate-y-0.5 transition-all duration-200">
                    Calculate Ranks
                </button>
            </div>

            <!-- Step 4: Results -->
            <div id="resultsContainer" class="mt-8 hidden">
                 <h2 class="text-lg font-semibold text-gray-700 mb-3">Step 3: Ranked Results</h2>
                <div id="resultsTable" class="overflow-x-auto">
                    <!-- The ranked table will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM ELEMENTS ---
            const apiKeyInput = document.getElementById('apiKey');
            const secretKeyInput = document.getElementById('secretKey');
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const symphonyIdsInput = document.getElementById('symphonyIds');
            const weightsContainer = document.getElementById('weightsContainer');
            const totalWeightEl = document.getElementById('totalWeight');
            const calculateBtn = document.getElementById('calculateBtn');
            const resultsContainer = document.getElementById('resultsContainer');
            const resultsTable = document.getElementById('resultsTable');

            // --- INITIAL DATA & CONFIG ---
            const metrics = [
                { name: 'Ann. Return (%)', id: 'annReturn', weight: 34, higherIsBetter: true },
                { name: 'Max Drawdown (%)', id: 'maxDrawdown', weight: 33, higherIsBetter: false },
                { name: 'Std. Dev. (%)', id: 'stdDev', weight: 33, higherIsBetter: false },
            ];

            // --- FUNCTIONS ---

            // Create and initialize sliders for weights
            function createSliders() {
                weightsContainer.innerHTML = '';
                metrics.forEach(metric => {
                    const sliderDiv = document.createElement('div');
                    sliderDiv.className = 'flex flex-col';
                    sliderDiv.innerHTML = `
                        <label for="${metric.id}Weight" class="flex justify-between items-center text-sm font-medium text-gray-600 mb-1">
                            <span>${metric.name}</span>
                            <span id="${metric.id}Value" class="font-semibold text-blue-600">${metric.weight}%</span>
                        </label>
                        <input type="range" id="${metric.id}Weight" min="0" max="100" value="${metric.weight}" class="w-full">
                    `;
                    weightsContainer.appendChild(sliderDiv);
                });
                attachSliderListeners();
            }

            // Attach listeners to sliders to handle weight distribution
            function attachSliderListeners() {
                const sliders = metrics.map(m => document.getElementById(`${m.id}Weight`));
                sliders.forEach((slider, index) => {
                    slider.addEventListener('input', () => {
                        updateWeights(index, parseInt(slider.value));
                    });
                });
            }

            // Update weights when a slider is moved, ensuring total is 100%
            function updateWeights(changedIndex, newValue) {
                const sliders = metrics.map(m => document.getElementById(`${m.id}Weight`));
                let currentTotal = metrics.reduce((sum, m, i) => sum + (i === changedIndex ? 0 : parseInt(sliders[i].value)), 0);

                let remaining = 100 - newValue;
                if (currentTotal > 0) {
                    metrics.forEach((metric, i) => {
                        if (i !== changedIndex) {
                            metric.weight = (parseInt(sliders[i].value) / currentTotal) * remaining;
                        } else {
                            metric.weight = newValue;
                        }
                    });
                } else { // Handle case where other sliders are all zero
                    const adjustment = remaining / (metrics.length - 1);
                    metrics.forEach((metric, i) => {
                        metric.weight = (i === changedIndex) ? newValue : adjustment;
                    });
                }

                // Final pass to ensure total is exactly 100 due to rounding
                let finalTotal = metrics.reduce((sum, m) => sum + m.weight, 0);
                let roundingError = 100 - finalTotal;
                metrics[changedIndex].weight += roundingError;

                // Update UI
                metrics.forEach((metric, i) => {
                    const roundedWeight = Math.round(metric.weight);
                    sliders[i].value = roundedWeight;
                    document.getElementById(`${metric.id}Value`).textContent = `${roundedWeight}%`;
                });
            }

            // Main calculation logic
            function calculateAndRank(data) {
                if (!data || data.length === 0) {
                    showModal("No data to process. Please fetch data from the API.");
                    return;
                }

                const dataKeys = {
                    annReturn: 'annualized_rate_of_return',
                    maxDrawdown: 'max_drawdown',
                    stdDev: 'standard_deviation'
                };

                // Find min/max for each metric
                const minMax = {};
                metrics.forEach(metric => {
                    const key = dataKeys[metric.id];
                    let values = data.map(d => d[key]).filter(v => typeof v === 'number');
                    if (metric.id === 'maxDrawdown') {
                        values = values.map(v => Math.abs(v));
                    }
                    if (values.length === 0) {
                        showModal(`Error: No numerical data found for the column "${metric.name}". Please check your input.`);
                        return;
                    }
                    minMax[metric.id] = {
                        min: Math.min(...values),
                        max: Math.max(...values)
                    };
                });

                // Normalize, score, and calculate final weighted score
                const scoredData = data.map(entry => {
                    const scores = {};
                    metrics.forEach(metric => {
                        const key = dataKeys[metric.id];
                        const { min, max } = minMax[metric.id];
                        let value = entry[key];
                        if (metric.id === 'maxDrawdown') {
                            value = Math.abs(value);
                        }

                        let normalized = 0;
                        if (max > min) {
                            normalized = 100 * (value - min) / (max - min);
                        } else if (value === max) {
                            normalized = 100;
                        }

                        scores[metric.id] = metric.higherIsBetter ? normalized : (100 - normalized);
                    });

                    const finalScore = metrics.reduce((total, metric) => {
                        const slider = document.getElementById(`${metric.id}Weight`);
                        const weight = parseInt(slider.value);
                        return total + (scores[metric.id] * (weight / 100));
                    }, 0);

                    return { ...entry, scores, finalScore };
                });

                // Sort by final score and add rank
                scoredData.sort((a, b) => b.finalScore - a.finalScore);
                const rankedData = scoredData.map((entry, index) => ({ ...entry, rank: index + 1 }));

                renderTable(rankedData);
            }

            // Render the final ranked table
            function renderTable(rankedData) {
                let tableHTML = `
                    <table class="w-full text-sm text-left text-gray-500">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-100">
                            <tr>
                                <th scope="col" class="px-4 py-3">Rank</th>
                                <th scope="col" class="px-4 py-3">Symphony</th>
                                <th scope="col" class="px-4 py-3 text-right">Ann. Return (Score)</th>
                                <th scope="col" class="px-4 py-3 text-right">Max Drawdown (Score)</th>
                                <th scope="col" class="px-4 py-3 text-right">Std. Dev. (Score)</th>
                                <th scope="col" class="px-4 py-3 text-right font-bold text-gray-900">Final Score</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                rankedData.forEach(entry => {
                    tableHTML += `
                        <tr class="bg-white border-b hover:bg-gray-50">
                            <td class="px-4 py-3 font-bold text-lg text-gray-900">${entry.rank}</td>
                            <td class="px-4 py-3 font-medium text-gray-900">${entry.symphony}</td>
                            <td class="px-4 py-3 text-right">${entry.scores.annReturn.toFixed(1)}</td>
                            <td class="px-4 py-3 text-right">${entry.scores.maxDrawdown.toFixed(1)}</td>
                            <td class="px-4 py-3 text-right">${entry.scores.stdDev.toFixed(1)}</td>
                            <td class="px-4 py-3 text-right font-bold text-lg text-blue-600">${entry.finalScore.toFixed(1)}</td>
                        </tr>
                    `;
                });

                tableHTML += `</tbody></table>`;
                resultsTable.innerHTML = tableHTML;
                resultsContainer.classList.remove('hidden');
            }

            // Function to show a custom modal instead of alert()
            function showModal(message) {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center';
                modal.innerHTML = `
                    <div class="bg-white p-5 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <h3 class="text-lg font-medium leading-6 text-gray-900 mb-2">Notice</h3>
                        <p class="text-sm text-gray-500 mb-4">${message}</p>
                        <button id="modalCloseBtn" class="bg-blue-600 text-white px-4 py-2 rounded-md">OK</button>
                    </div>
                `;
                document.body.appendChild(modal);
                document.getElementById('modalCloseBtn').onclick = () => {
                    document.body.removeChild(modal);
                };
            }

            // --- INITIALIZATION ---
            createSliders();
            calculateBtn.addEventListener('click', handleCalculateClick);

            async function handleCalculateClick() {
                const apiKey = apiKeyInput.value.trim();
                const secretKey = secretKeyInput.value.trim();
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const symphonyIds = symphonyIdsInput.value.trim().split('\n').filter(id => id.trim() !== '');

                if (!apiKey || !secretKey || !startDate || !endDate || symphonyIds.length === 0) {
                    showModal("Please fill in all API details, dates, and provide at least one Symphony ID.");
                    return;
                }

                calculateBtn.disabled = true;
                calculateBtn.textContent = 'Calculating...';

                const allSymphonyData = [];

                for (const symphonyId of symphonyIds) {
                    const data = await fetchBacktestData(apiKey, secretKey, symphonyId, startDate, endDate);
                    if (data) {
                        allSymphonyData.push({
                            symphony: symphonyId,
                            ...data.stats
                        });
                    }
                }

                calculateAndRank(allSymphonyData);

                calculateBtn.disabled = false;
                calculateBtn.textContent = 'Calculate Ranks';
            }

            async function fetchBacktestData(apiKey, secretKey, symphonyId, startDate, endDate) {
                const url = `https://backtest-api.composer.trade/api/v2/public/symphonies/${symphonyId}/backtest`;

                const headers = {
                    'Authorization': `Bearer ${secretKey}`,
                    'x-api-key-id': apiKey,
                    'x-origin': 'public-api',
                    'Content-Type': 'application/json'
                };

                const body = {
                    capital: 10000,
                    start_date: startDate,
                    end_date: endDate,
                    broker: "apex",
                    slippage_percent: 0.0005,
                    backtest_version: "v2",
                    apply_reg_fee: true,
                    apply_taf_fee: true
                };

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(body)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        showModal(`API Error for ${symphonyId}: ${response.status} ${errorText}`);
                        return null;
                    }
                    return await response.json();
                } catch (error) {
                    showModal(`Network Error for ${symphonyId}: ${error.message}`);
                    return null;
                }
            }
        });
    </script>

</body>
</html>
